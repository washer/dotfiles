{
  "version": 3,
  "sources": ["../src/generateUlid.tsx", "../node_modules/ulidx/dist/node/index.js", "../node_modules/layerr/dist/error.js", "../node_modules/layerr/dist/global.js", "../node_modules/layerr/dist/tools.js", "../node_modules/layerr/dist/layerr.js", "../src/uuidHistory.ts", "../src/utils/uuidUtils.ts"],
  "sourcesContent": ["import { showHUD, Clipboard, getPreferenceValues, showToast, Toast, LaunchProps } from \"@raycast/api\";\nimport { monotonicFactory } from \"ulidx\";\n\nimport { generateUuids } from \"./utils/uuidUtils\";\nimport { UUIDType } from \"./uuidHistory\";\n\n// This is required to ensure generated ULIDs are sortable\n// https://github.com/ulid/javascript#monotonic-ulids\nconst ulid = monotonicFactory();\n\n// don't want to cause a heap error, so cap it \uD83D\uDE31\nconst ULID_MAX_NUMBER = 10000;\n\nexport default async (props: LaunchProps<{ arguments: Arguments.GenerateUlid }>) => {\n  let { numberOfULIDsToGenerate } = props.arguments;\n  const { upperCaseLetters, defaultAction } = getPreferenceValues<Preferences.GenerateUlid>();\n\n  if (!numberOfULIDsToGenerate) {\n    numberOfULIDsToGenerate = \"1\";\n  }\n\n  try {\n    const parseableNumber = parseInt(numberOfULIDsToGenerate, 10);\n\n    if (isNaN(parseableNumber)) {\n      throw new Error(\"INVALID_NUMBER\");\n    }\n\n    // safe?\n    if (parseableNumber <= ULID_MAX_NUMBER) {\n      const ulids = await generateUuids(ulid, parseableNumber, upperCaseLetters, UUIDType.ULID);\n\n      if (defaultAction === \"copy\") {\n        await Clipboard.copy(ulids.join(\"\\r\\n\"));\n      } else if (defaultAction === \"paste\") {\n        await Clipboard.paste(ulids.join(\"\\r\\n\"));\n      }\n      const action = defaultAction === \"copy\" ? \"Copied\" : \"Pasted\";\n      const successMessage = ulids.length > 1 ? `${action} ${ulids.length} new ULIDs.` : `${action} new ULID: ${ulids}`;\n      await showHUD(`\u2705 ${successMessage}`);\n    } else {\n      await showToast({\n        style: Toast.Style.Failure,\n        title: \"Too many ULIDs requested.\",\n        message: `${parseableNumber} exceeds maximum ULIDs of ${ULID_MAX_NUMBER}. Try a lower number.`,\n      });\n    }\n  } catch (e) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Invalid number.\",\n      message: \"An invalid number has been provided. Try an actual number.\",\n    });\n  }\n};\n", "import crypto from 'node:crypto';\nimport { Layerr } from 'layerr';\n\nconst B32_CHARACTERS = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\nconst MAX_ULID = \"7ZZZZZZZZZZZZZZZZZZZZZZZZZ\";\nconst MIN_ULID = \"00000000000000000000000000\";\nconst ULID_REGEX = /^[0-7][0-9a-hjkmnp-tv-zA-HJKMNP-TV-Z]{25}$/;\nconst UUID_REGEX = /^[0-9a-fA-F]{8}-(?:[0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/;\n\n// Code from https://github.com/devbanana/crockford-base32/blob/develop/src/index.ts\nfunction crockfordEncode(input) {\n    const output = [];\n    let bitsRead = 0;\n    let buffer = 0;\n    const reversedInput = new Uint8Array(input.slice().reverse());\n    for (const byte of reversedInput) {\n        buffer |= byte << bitsRead;\n        bitsRead += 8;\n        while (bitsRead >= 5) {\n            output.unshift(buffer & 0x1f);\n            buffer >>>= 5;\n            bitsRead -= 5;\n        }\n    }\n    if (bitsRead > 0) {\n        output.unshift(buffer & 0x1f);\n    }\n    return output.map(byte => B32_CHARACTERS.charAt(byte)).join(\"\");\n}\nfunction crockfordDecode(input) {\n    const sanitizedInput = input.toUpperCase().split(\"\").reverse().join(\"\");\n    const output = [];\n    let bitsRead = 0;\n    let buffer = 0;\n    for (const character of sanitizedInput) {\n        const byte = B32_CHARACTERS.indexOf(character);\n        if (byte === -1) {\n            throw new Error(`Invalid base 32 character found in string: ${character}`);\n        }\n        buffer |= byte << bitsRead;\n        bitsRead += 5;\n        while (bitsRead >= 8) {\n            output.unshift(buffer & 0xff);\n            buffer >>>= 8;\n            bitsRead -= 8;\n        }\n    }\n    if (bitsRead >= 5 || buffer > 0) {\n        output.unshift(buffer & 0xff);\n    }\n    return new Uint8Array(output);\n}\n\n// These values should NEVER change. The values are precisely for\n// generating ULIDs.\nconst ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nconst ENCODING_LEN = 32; // from ENCODING.length;\nconst TIME_MAX = 281474976710655; // from Math.pow(2, 48) - 1;\nconst TIME_LEN = 10;\nconst RANDOM_LEN = 16;\nconst ERROR_INFO = Object.freeze({\n    source: \"ulid\"\n});\n/**\n * Decode time from a ULID\n * @param id The ULID\n * @returns The decoded timestamp\n */\nfunction decodeTime(id) {\n    if (id.length !== TIME_LEN + RANDOM_LEN) {\n        throw new Layerr({\n            info: {\n                code: \"DEC_TIME_MALFORMED\",\n                ...ERROR_INFO\n            }\n        }, \"Malformed ULID\");\n    }\n    const time = id\n        .substr(0, TIME_LEN)\n        .toUpperCase()\n        .split(\"\")\n        .reverse()\n        .reduce((carry, char, index) => {\n        const encodingIndex = ENCODING.indexOf(char);\n        if (encodingIndex === -1) {\n            throw new Layerr({\n                info: {\n                    code: \"DEC_TIME_CHAR\",\n                    ...ERROR_INFO\n                }\n            }, `Time decode error: Invalid character: ${char}`);\n        }\n        return (carry += encodingIndex * Math.pow(ENCODING_LEN, index));\n    }, 0);\n    if (time > TIME_MAX) {\n        throw new Layerr({\n            info: {\n                code: \"DEC_TIME_CHAR\",\n                ...ERROR_INFO\n            }\n        }, `Malformed ULID: timestamp too large: ${time}`);\n    }\n    return time;\n}\n/**\n * Detect the best PRNG (pseudo-random number generator)\n * @param root The root to check from (global/window)\n * @returns The PRNG function\n */\nfunction detectPRNG(root) {\n    const rootLookup = root || detectRoot();\n    const globalCrypto = (rootLookup && (rootLookup.crypto || rootLookup.msCrypto)) ||\n        (typeof crypto !== \"undefined\" ? crypto : null);\n    if (typeof globalCrypto?.getRandomValues === \"function\") {\n        return () => {\n            const buffer = new Uint8Array(1);\n            globalCrypto.getRandomValues(buffer);\n            return buffer[0] / 0xff;\n        };\n    }\n    else if (typeof globalCrypto?.randomBytes === \"function\") {\n        return () => globalCrypto.randomBytes(1).readUInt8() / 0xff;\n    }\n    else if (crypto?.randomBytes) {\n        return () => crypto.randomBytes(1).readUInt8() / 0xff;\n    }\n    throw new Layerr({\n        info: {\n            code: \"PRNG_DETECT\",\n            ...ERROR_INFO\n        }\n    }, \"Failed to find a reliable PRNG\");\n}\nfunction detectRoot() {\n    if (inWebWorker())\n        return self;\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    return null;\n}\nfunction encodeRandom(len, prng) {\n    let str = \"\";\n    for (; len > 0; len--) {\n        str = randomChar(prng) + str;\n    }\n    return str;\n}\n/**\n * Encode the time portion of a ULID\n * @param now The current timestamp\n * @param len Length to generate\n * @returns The encoded time\n */\nfunction encodeTime(now, len) {\n    if (isNaN(now)) {\n        throw new Layerr({\n            info: {\n                code: \"ENC_TIME_NAN\",\n                ...ERROR_INFO\n            }\n        }, `Time must be a number: ${now}`);\n    }\n    else if (now > TIME_MAX) {\n        throw new Layerr({\n            info: {\n                code: \"ENC_TIME_SIZE_EXCEED\",\n                ...ERROR_INFO\n            }\n        }, `Cannot encode a time larger than ${TIME_MAX}: ${now}`);\n    }\n    else if (now < 0) {\n        throw new Layerr({\n            info: {\n                code: \"ENC_TIME_NEG\",\n                ...ERROR_INFO\n            }\n        }, `Time must be positive: ${now}`);\n    }\n    else if (Number.isInteger(now) === false) {\n        throw new Layerr({\n            info: {\n                code: \"ENC_TIME_TYPE\",\n                ...ERROR_INFO\n            }\n        }, `Time must be an integer: ${now}`);\n    }\n    let mod, str = \"\";\n    for (let currentLen = len; currentLen > 0; currentLen--) {\n        mod = now % ENCODING_LEN;\n        str = ENCODING.charAt(mod) + str;\n        now = (now - mod) / ENCODING_LEN;\n    }\n    return str;\n}\n/**\n * Fix a ULID's Base32 encoding -\n * i and l (case-insensitive) will be treated as 1 and o (case-insensitive) will be treated as 0.\n * hyphens are ignored during decoding.\n * @param id The ULID\n * @returns The cleaned up ULID\n */\nfunction fixULIDBase32(id) {\n    return id.replace(/i/gi, \"1\").replace(/l/gi, \"1\").replace(/o/gi, \"0\").replace(/-/g, \"\");\n}\nfunction incrementBase32(str) {\n    let done = undefined, index = str.length, char, charIndex, output = str;\n    const maxCharIndex = ENCODING_LEN - 1;\n    while (!done && index-- >= 0) {\n        char = output[index];\n        charIndex = ENCODING.indexOf(char);\n        if (charIndex === -1) {\n            throw new Layerr({\n                info: {\n                    code: \"B32_INC_ENC\",\n                    ...ERROR_INFO\n                }\n            }, \"Incorrectly encoded string\");\n        }\n        if (charIndex === maxCharIndex) {\n            output = replaceCharAt(output, index, ENCODING[0]);\n            continue;\n        }\n        done = replaceCharAt(output, index, ENCODING[charIndex + 1]);\n    }\n    if (typeof done === \"string\") {\n        return done;\n    }\n    throw new Layerr({\n        info: {\n            code: \"B32_INC_INVALID\",\n            ...ERROR_INFO\n        }\n    }, \"Failed incrementing string\");\n}\nfunction inWebWorker() {\n    // @ts-ignore\n    return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n}\n/**\n * Check if a ULID is valid\n * @param id The ULID to test\n * @returns True if valid, false otherwise\n * @example\n *   isValid(\"01HNZX8JGFACFA36RBXDHEQN6E\"); // true\n *   isValid(\"\"); // false\n */\nfunction isValid(id) {\n    return (typeof id === \"string\" &&\n        id.length === TIME_LEN + RANDOM_LEN &&\n        id\n            .toUpperCase()\n            .split(\"\")\n            .every(char => ENCODING.indexOf(char) !== -1));\n}\n/**\n * Create a ULID factory to generate monotonically-increasing\n *  ULIDs\n * @param prng The PRNG to use\n * @returns A ulid factory\n * @example\n *  const ulid = monotonicFactory();\n *  ulid(); // \"01HNZXD07M5CEN5XA66EMZSRZW\"\n */\nfunction monotonicFactory(prng) {\n    const currentPRNG = prng || detectPRNG();\n    let lastTime = 0, lastRandom;\n    return function _ulid(seedTime) {\n        const seed = isNaN(seedTime) ? Date.now() : seedTime;\n        if (seed <= lastTime) {\n            const incrementedRandom = (lastRandom = incrementBase32(lastRandom));\n            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n        }\n        lastTime = seed;\n        const newRandom = (lastRandom = encodeRandom(RANDOM_LEN, currentPRNG));\n        return encodeTime(seed, TIME_LEN) + newRandom;\n    };\n}\nfunction randomChar(prng) {\n    let rand = Math.floor(prng() * ENCODING_LEN);\n    if (rand === ENCODING_LEN) {\n        rand = ENCODING_LEN - 1;\n    }\n    return ENCODING.charAt(rand);\n}\nfunction replaceCharAt(str, index, char) {\n    if (index > str.length - 1) {\n        return str;\n    }\n    return str.substr(0, index) + char + str.substr(index + 1);\n}\n/**\n * Generate a ULID\n * @param seedTime Optional time seed\n * @param prng Optional PRNG function\n * @returns A ULID string\n * @example\n *  ulid(); // \"01HNZXD07M5CEN5XA66EMZSRZW\"\n */\nfunction ulid(seedTime, prng) {\n    const currentPRNG = prng || detectPRNG();\n    const seed = isNaN(seedTime) ? Date.now() : seedTime;\n    return encodeTime(seed, TIME_LEN) + encodeRandom(RANDOM_LEN, currentPRNG);\n}\n/**\n * Convert a ULID to a UUID\n * @param ulid The ULID to convert\n * @returns A UUID string\n */\nfunction ulidToUUID(ulid) {\n    const isValid = ULID_REGEX.test(ulid);\n    if (!isValid) {\n        throw new Layerr({ info: { code: \"INVALID_ULID\", ...ERROR_INFO } }, \"Invalid ULID\");\n    }\n    const uint8Array = crockfordDecode(ulid);\n    let uuid = Array.from(uint8Array)\n        .map(byte => byte.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n    uuid =\n        uuid.substring(0, 8) +\n            \"-\" +\n            uuid.substring(8, 12) +\n            \"-\" +\n            uuid.substring(12, 16) +\n            \"-\" +\n            uuid.substring(16, 20) +\n            \"-\" +\n            uuid.substring(20);\n    return uuid;\n}\n/**\n * Convert a UUID to a ULID\n * @param uuid The UUID to convert\n * @returns A ULID string\n */\nfunction uuidToULID(uuid) {\n    const isValid = UUID_REGEX.test(uuid);\n    if (!isValid) {\n        throw new Layerr({ info: { code: \"INVALID_UUID\", ...ERROR_INFO } }, \"Invalid UUID\");\n    }\n    const uint8Array = new Uint8Array(uuid\n        .replace(/-/g, \"\")\n        .match(/.{1,2}/g)\n        .map(byte => parseInt(byte, 16)));\n    return crockfordEncode(uint8Array);\n}\n\nexport { B32_CHARACTERS, MAX_ULID, MIN_ULID, ULID_REGEX, UUID_REGEX, decodeTime, detectPRNG, encodeTime, fixULIDBase32, isValid, monotonicFactory, ulid, ulidToUUID, uuidToULID };\n", "export function assertError(err) {\n    if (!isError(err)) {\n        throw new Error(\"Parameter was not an error\");\n    }\n}\nexport function isError(err) {\n    return ((!!err &&\n        typeof err === \"object\" &&\n        objectToString(err) === \"[object Error]\") ||\n        err instanceof Error);\n}\nfunction objectToString(obj) {\n    return Object.prototype.toString.call(obj);\n}\n", "const NAME = \"Layerr\";\nlet __name = NAME;\nexport function getGlobalName() {\n    return __name;\n}\nexport function setGlobalName(name = null) {\n    __name = name ?? NAME;\n}\n", "import { isError } from \"./error.js\";\nexport function parseArguments(args) {\n    let options, shortMessage = \"\";\n    if (args.length === 0) {\n        options = {};\n    }\n    else if (isError(args[0])) {\n        options = {\n            cause: args[0],\n        };\n        shortMessage = args.slice(1).join(\" \") || \"\";\n    }\n    else if (args[0] && typeof args[0] === \"object\") {\n        options = Object.assign({}, args[0]);\n        shortMessage = args.slice(1).join(\" \") || \"\";\n    }\n    else if (typeof args[0] === \"string\") {\n        options = {};\n        shortMessage = shortMessage = args.join(\" \") || \"\";\n    }\n    else {\n        throw new Error(\"Invalid arguments passed to Layerr\");\n    }\n    return {\n        options,\n        shortMessage,\n    };\n}\n", "import { assertError, isError } from \"./error.js\";\nimport { getGlobalName } from \"./global.js\";\nimport { parseArguments } from \"./tools.js\";\nexport class Layerr extends Error {\n    constructor(errorOptionsOrMessage, messageText) {\n        const args = [...arguments];\n        const { options, shortMessage } = parseArguments(args);\n        let message = shortMessage;\n        if (options.cause) {\n            message = `${message}: ${options.cause.message}`;\n        }\n        super(message);\n        this.message = message;\n        if (options.name && typeof options.name === \"string\") {\n            this.name = options.name;\n        }\n        else {\n            this.name = getGlobalName();\n        }\n        if (options.cause) {\n            Object.defineProperty(this, \"_cause\", { value: options.cause });\n        }\n        Object.defineProperty(this, \"_info\", { value: {} });\n        if (options.info && typeof options.info === \"object\") {\n            Object.assign(this._info, options.info);\n        }\n        if (Error.captureStackTrace) {\n            const ctor = options.constructorOpt || this.constructor;\n            Error.captureStackTrace(this, ctor);\n        }\n    }\n    static cause(err) {\n        assertError(err);\n        if (!err._cause)\n            return null;\n        return isError(err._cause)\n            ? err._cause\n            : null;\n    }\n    static fullStack(err) {\n        assertError(err);\n        const cause = Layerr.cause(err);\n        if (cause) {\n            return `${err.stack}\\ncaused by: ${Layerr.fullStack(cause)}`;\n        }\n        return err.stack ?? \"\";\n    }\n    static info(err) {\n        assertError(err);\n        const output = {};\n        const cause = Layerr.cause(err);\n        if (cause) {\n            Object.assign(output, Layerr.info(cause));\n        }\n        if (err._info) {\n            Object.assign(output, err._info);\n        }\n        return output;\n    }\n    toString() {\n        let output = this.name ||\n            this.constructor.name ||\n            this.constructor.prototype.name;\n        if (this.message) {\n            output = `${output}: ${this.message}`;\n        }\n        return output;\n    }\n}\n", "import { LocalStorage, showToast, Toast } from \"@raycast/api\";\n\nexport interface HistoryEntry {\n  uuid: string;\n  timestamp: Date;\n  type: string;\n}\n\nexport enum UUIDType {\n  UUIDV4 = \"uuidV4\",\n  UUIDV5 = \"uuidV5\",\n  UUIDV7 = \"uuidV7\",\n  ULID = \"ulid\",\n  TYPEID = \"typeid\",\n}\n\nexport const addToHistory = async (uuid: string, type: UUIDType) => {\n  try {\n    let currentHistory = await LocalStorage.getItem(\"uuidHistory\");\n\n    if (!currentHistory) {\n      currentHistory = \"[]\";\n    }\n\n    if (typeof currentHistory !== \"string\") {\n      return;\n    }\n\n    const parsedHistory = JSON.parse(currentHistory);\n\n    parsedHistory.push({ uuid, timestamp: new Date(), type });\n\n    await LocalStorage.setItem(\"uuidHistory\", JSON.stringify(parsedHistory));\n  } catch (error) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Error saving history\",\n      message: \"Failed to save history to local storage\",\n    });\n  }\n};\n\nexport const getHistory = async (): Promise<HistoryEntry[]> => {\n  try {\n    const result = await LocalStorage.getItem(\"uuidHistory\");\n\n    if (!result) {\n      return [];\n    }\n\n    if (typeof result !== \"string\") {\n      throw new Error(\"Invalid data type: Expected a string\");\n    }\n\n    if (result) {\n      const history = JSON.parse(result);\n      return history;\n    } else {\n      return [];\n    }\n  } catch (error) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Error fetching history\",\n      message: \"Failed to retrieve history from local storage\",\n    });\n    return [];\n  }\n};\n\nexport const clearHistory = () => {\n  LocalStorage.removeItem(\"uuidHistory\")\n    .then(() => {\n      showToast({\n        style: Toast.Style.Success,\n        title: \"History Cleared\",\n        message: \"UUID history has been successfully cleared.\",\n      });\n    })\n    .catch((error) => {\n      console.error(\"Failed to clear history from local storage:\", error);\n      showToast({\n        style: Toast.Style.Failure,\n        title: \"Error clearing history\",\n        message: \"Failed to clear history from local storage\",\n      });\n    });\n};\n\nexport const deleteHistoryEntry = async (uuidToDelete: string) => {\n  try {\n    const result = await LocalStorage.getItem(\"uuidHistory\");\n\n    if (!result) {\n      return []; // No history found, return empty array\n    }\n\n    if (typeof result !== \"string\") {\n      throw new Error(\"Invalid data type: Expected a string\");\n    }\n\n    if (result) {\n      const history = JSON.parse(result) as HistoryEntry[];\n      const updatedHistory = history.filter((entry) => entry.uuid !== uuidToDelete);\n      await LocalStorage.setItem(\"uuidHistory\", JSON.stringify(updatedHistory));\n      return updatedHistory; // Return the updated history after deletion\n    } else {\n      return []; // No history found, return empty array\n    }\n  } catch (error) {\n    console.error(\"Failed to delete history entry:\", error);\n    return []; // Return empty array in case of error\n  }\n};\n", "import { addToHistory, UUIDType } from \"../uuidHistory\"; // Adjust the path based on your directory structure\n\nexport async function generateUuids(\n  uuidGenerator: () => string,\n  numberOfUuids: number,\n  upperCaseLetters = false,\n  type: UUIDType = UUIDType.UUIDV4,\n): Promise<string[]> {\n  const uuids = Array.from(Array(numberOfUuids)).map(() => {\n    const newUuid = uuidGenerator();\n    return upperCaseLetters ? newUuid.toUpperCase() : newUuid;\n  });\n\n  for (const uuid of uuids) {\n    await addToHistory(uuid, type);\n  }\n\n  return uuids;\n}\n"],
  "mappings": "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",
  "names": ["generateUlid_exports", "__export", "generateUlid_default", "__toCommonJS", "import_api", "import_node_crypto", "assertError", "err", "isError", "objectToString", "obj", "NAME", "__name", "getGlobalName", "parseArguments", "args", "options", "shortMessage", "isError", "Layerr", "_Layerr", "errorOptionsOrMessage", "messageText", "args", "options", "shortMessage", "parseArguments", "message", "getGlobalName", "ctor", "err", "assertError", "isError", "cause", "output", "ENCODING", "ENCODING_LEN", "TIME_MAX", "TIME_LEN", "RANDOM_LEN", "ERROR_INFO", "detectPRNG", "root", "rootLookup", "detectRoot", "globalCrypto", "crypto", "buffer", "Layerr", "ERROR_INFO", "inWebWorker", "encodeRandom", "len", "prng", "str", "randomChar", "encodeTime", "now", "TIME_MAX", "mod", "currentLen", "ENCODING_LEN", "ENCODING", "incrementBase32", "str", "done", "index", "char", "charIndex", "output", "maxCharIndex", "ENCODING_LEN", "ENCODING", "Layerr", "ERROR_INFO", "replaceCharAt", "inWebWorker", "monotonicFactory", "prng", "currentPRNG", "detectPRNG", "lastTime", "lastRandom", "seedTime", "seed", "incrementedRandom", "incrementBase32", "encodeTime", "TIME_LEN", "newRandom", "encodeRandom", "RANDOM_LEN", "randomChar", "rand", "ENCODING_LEN", "ENCODING", "replaceCharAt", "str", "index", "char", "import_api", "addToHistory", "uuid", "type", "currentHistory", "parsedHistory", "generateUuids", "uuidGenerator", "numberOfUuids", "upperCaseLetters", "type", "uuids", "newUuid", "uuid", "addToHistory", "ulid", "monotonicFactory", "ULID_MAX_NUMBER", "generateUlid_default", "props", "numberOfULIDsToGenerate", "upperCaseLetters", "defaultAction", "parseableNumber", "ulids", "generateUuids", "action", "successMessage"]
}
