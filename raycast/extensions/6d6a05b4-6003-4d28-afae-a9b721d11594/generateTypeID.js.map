{
  "version": 3,
  "sources": ["../src/generateTypeID.ts", "../node_modules/typeid-js/node_modules/uuid/dist/esm-node/regex.js", "../node_modules/typeid-js/node_modules/uuid/dist/esm-node/validate.js", "../node_modules/typeid-js/node_modules/uuid/dist/esm-node/stringify.js", "../node_modules/typeid-js/node_modules/uuid/dist/esm-node/rng.js", "../node_modules/typeid-js/node_modules/uuid/dist/esm-node/v7.js", "../node_modules/typeid-js/src/typeid.ts", "../node_modules/typeid-js/src/parse_uuid.ts", "../node_modules/typeid-js/src/base32.ts", "../node_modules/typeid-js/src/unboxed/typeid.ts", "../node_modules/typeid-js/src/prefix.ts", "../node_modules/typeid-js/src/unboxed/error.ts", "../src/uuidHistory.ts", "../src/utils/uuidUtils.ts"],
  "sourcesContent": ["import { Clipboard, getPreferenceValues, LaunchProps, showHUD, showToast, Toast } from \"@raycast/api\";\nimport { typeid } from \"typeid-js\";\n\nimport { generateUuids } from \"./utils/uuidUtils\";\nimport { UUIDType } from \"./uuidHistory\";\n\n// don't want to cause a heap error, so cap it \uD83D\uDE31\nconst UUID_MAX_NUMBER = 10000;\n\nexport default async (props: LaunchProps<{ arguments: Arguments.GenerateTypeID }>) => {\n  if (!props.arguments.numberOfUUIDsToGenerate) props.arguments.numberOfUUIDsToGenerate = \"1\";\n\n  const { prefix, numberOfUUIDsToGenerate } = props.arguments;\n  const { upperCaseLetters, defaultAction } = getPreferenceValues<Preferences.GenerateTypeID>();\n\n  try {\n    const parseableNumber = parseInt(numberOfUUIDsToGenerate, 10);\n\n    if (isNaN(parseableNumber)) {\n      throw new Error(\"INVALID_NUMBER\");\n    }\n\n    // safe?\n    if (parseableNumber <= UUID_MAX_NUMBER) {\n      const uuids = await generateUuids(\n        () => typeid(prefix).toString(),\n        parseableNumber,\n        upperCaseLetters,\n        UUIDType.TYPEID,\n      );\n\n      if (defaultAction === \"copy\") {\n        await Clipboard.copy(uuids.join(\"\\r\\n\"));\n      } else if (defaultAction === \"paste\") {\n        await Clipboard.paste(uuids.join(\"\\r\\n\"));\n      }\n      const action = defaultAction === \"copy\" ? \"Copied\" : \"Pasted\";\n      const successMessage = uuids.length > 1 ? `${action} ${uuids.length} new UUIDs.` : `${action} new UUID: ${uuids}`;\n      await showHUD(`\u2705 ${successMessage}`);\n    } else {\n      await showToast({\n        style: Toast.Style.Failure,\n        title: \"Too many UUIDs requested.\",\n        message: `${parseableNumber} exceeds maximum UUIDs of ${UUID_MAX_NUMBER}. Try a lower number.`,\n      });\n    }\n  } catch (e) {\n    switch ((e as { message: string }).message) {\n      case \"INVALID_NUMBER\":\n        await showToast({\n          style: Toast.Style.Failure,\n          title: \"Invalid number.\",\n          message: \"An invalid number has been provided. Try an actual number.\",\n        });\n        break;\n      case \"Invalid prefix. Must be at most 63 ascii letters [a-z_]\":\n        await showToast({\n          style: Toast.Style.Failure,\n          title: \"Invalid prefix.\",\n          message: \"Must be at most 63 ascii letters [a-z_]\",\n        });\n        break;\n    }\n  }\n};\n", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;", "import REGEX from './regex.js';\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;", "import validate from './validate.js';\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nexport default stringify;", "import crypto from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}", "import rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nlet _seqLow = null;\nlet _seqHigh = null;\nlet _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  const rnds = options.random || (options.rng || rng)();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  const msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  let seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  let seqHigh = _seqHigh;\n  let seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || unsafeStringify(b);\n}\nexport default v7;", "import { stringify } from \"uuid\";\nimport { parseUUID } from \"./parse_uuid\";\nimport { encode, decode } from \"./base32\";\nimport {\n  typeidUnboxed,\n  getSuffix,\n  getType,\n  fromString,\n} from \"./unboxed/typeid\";\nimport { TypeIDConversionError } from \"./unboxed/error\";\n\nexport class TypeID<const T extends string> {\n  constructor(private prefix: T, private suffix: string = \"\") {\n    const typeIdRaw = typeidUnboxed(prefix, suffix);\n\n    this.prefix = getType(typeIdRaw);\n    this.suffix = getSuffix(typeIdRaw);\n  }\n\n  public getType(): T {\n    return this.prefix;\n  }\n\n  public getSuffix(): string {\n    return this.suffix;\n  }\n\n  public asType<const U extends string>(prefix: U): TypeID<U> {\n    const self = this as unknown as TypeID<U>;\n    if (self.prefix !== prefix) {\n      throw new TypeIDConversionError(self.prefix, prefix);\n    }\n    return self;\n  }\n\n  public toUUIDBytes(): Uint8Array {\n    return decode(this.suffix);\n  }\n\n  public toUUID(): string {\n    return stringify(this.toUUIDBytes());\n  }\n\n  public toString(): T extends \"\" ? string : `${T}_${string}` {\n    if (this.prefix === \"\") {\n      return this.suffix as T extends \"\" ? string : `${T}_${string}`;\n    }\n    return `${this.prefix}_${this.suffix}` as T extends \"\" ? string : `${T}_${string}`;\n  }\n\n  static fromString<const T extends string>(\n    str: string,\n    prefix?: T\n  ): TypeID<T> {\n    const typeIdRaw = fromString(str, prefix);\n\n    return new TypeID<T>(getType(typeIdRaw) as T, getSuffix(typeIdRaw));\n  }\n\n  static fromUUIDBytes<const T extends string>(\n    prefix: T,\n    bytes: Uint8Array\n  ): TypeID<T> {\n    const suffix = encode(bytes);\n    return new TypeID(prefix, suffix);\n  }\n\n  static fromUUID<const T extends string>(prefix: T, uuid: string): TypeID<T> {\n    const suffix = encode(parseUUID(uuid));\n    return new TypeID(prefix, suffix);\n  }\n}\n\nexport function typeid<T extends string>(): TypeID<\"\">;\nexport function typeid<T extends string>(prefix: T): TypeID<T>;\nexport function typeid<T extends string>(prefix: T, suffix: string): TypeID<T>;\nexport function typeid<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeID<T> {\n  return new TypeID(prefix, suffix);\n}\n", "/* eslint-disable no-bitwise */\nexport function parseUUID(uuid: string) {\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Block 1\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = (v >>> 16) & 0xff;\n  arr[2] = (v >>> 8) & 0xff;\n  arr[3] = v & 0xff;\n\n  // Block 2\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Block 3\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Block 4\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Block 5\n  arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff;\n  arr[11] = (v / 0x100000000) & 0xff;\n  arr[12] = (v >>> 24) & 0xff;\n  arr[13] = (v >>> 16) & 0xff;\n  arr[14] = (v >>> 8) & 0xff;\n  arr[15] = v & 0xff;\n\n  return arr;\n}\n", "/* eslint-disable no-bitwise */\nconst alphabet: string = \"0123456789abcdefghjkmnpqrstvwxyz\";\n\n// Decoding table\nconst dec: Uint8Array = new Uint8Array([\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03,\n  0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n  0x11, 0xff, 0x12, 0x13, 0xff, 0x14, 0x15, 0xff, 0x16, 0x17, 0x18, 0x19, 0x1a,\n  0xff, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n]);\n\nexport function encode(src: Uint8Array): string {\n  const dst: string[] = new Array(26).fill(\"\");\n\n  if (src.length !== 16) {\n    throw new Error(\n      `Invalid length. Expected 16 bytes, got ${src.length}. Input: ${src}`\n    );\n  }\n\n  // 10 byte timestamp\n  dst[0] = alphabet[(src[0] & 224) >> 5];\n  dst[1] = alphabet[src[0] & 31];\n  dst[2] = alphabet[(src[1] & 248) >> 3];\n  dst[3] = alphabet[((src[1] & 7) << 2) | ((src[2] & 192) >> 6)];\n  dst[4] = alphabet[(src[2] & 62) >> 1];\n  dst[5] = alphabet[((src[2] & 1) << 4) | ((src[3] & 240) >> 4)];\n  dst[6] = alphabet[((src[3] & 15) << 1) | ((src[4] & 128) >> 7)];\n  dst[7] = alphabet[(src[4] & 124) >> 2];\n  dst[8] = alphabet[((src[4] & 3) << 3) | ((src[5] & 224) >> 5)];\n  dst[9] = alphabet[src[5] & 31];\n\n  // 16 bytes of randomness\n  dst[10] = alphabet[(src[6] & 248) >> 3];\n  dst[11] = alphabet[((src[6] & 7) << 2) | ((src[7] & 192) >> 6)];\n  dst[12] = alphabet[(src[7] & 62) >> 1];\n  dst[13] = alphabet[((src[7] & 1) << 4) | ((src[8] & 240) >> 4)];\n  dst[14] = alphabet[((src[8] & 15) << 1) | ((src[9] & 128) >> 7)];\n  dst[15] = alphabet[(src[9] & 124) >> 2];\n  dst[16] = alphabet[((src[9] & 3) << 3) | ((src[10] & 224) >> 5)];\n  dst[17] = alphabet[src[10] & 31];\n  dst[18] = alphabet[(src[11] & 248) >> 3];\n  dst[19] = alphabet[((src[11] & 7) << 2) | ((src[12] & 192) >> 6)];\n  dst[20] = alphabet[(src[12] & 62) >> 1];\n  dst[21] = alphabet[((src[12] & 1) << 4) | ((src[13] & 240) >> 4)];\n  dst[22] = alphabet[((src[13] & 15) << 1) | ((src[14] & 128) >> 7)];\n  dst[23] = alphabet[(src[14] & 124) >> 2];\n  dst[24] = alphabet[((src[14] & 3) << 3) | ((src[15] & 224) >> 5)];\n  dst[25] = alphabet[src[15] & 31];\n\n  return dst.join(\"\");\n}\n\nexport function decode(s: string): Uint8Array {\n  if (s.length !== 26) {\n    throw new Error(\n      `Invalid length. Expected 26 bytes, got ${s.length}. Input: ${s}`\n    );\n  }\n\n  const encoder = new TextEncoder();\n  const v: Uint8Array = encoder.encode(s);\n\n  // Check if all the characters are part of the expected base32 character set.\n  if (\n    dec[v[0]] === 0xff ||\n    dec[v[1]] === 0xff ||\n    dec[v[2]] === 0xff ||\n    dec[v[3]] === 0xff ||\n    dec[v[4]] === 0xff ||\n    dec[v[5]] === 0xff ||\n    dec[v[6]] === 0xff ||\n    dec[v[7]] === 0xff ||\n    dec[v[8]] === 0xff ||\n    dec[v[9]] === 0xff ||\n    dec[v[10]] === 0xff ||\n    dec[v[11]] === 0xff ||\n    dec[v[12]] === 0xff ||\n    dec[v[13]] === 0xff ||\n    dec[v[14]] === 0xff ||\n    dec[v[15]] === 0xff ||\n    dec[v[16]] === 0xff ||\n    dec[v[17]] === 0xff ||\n    dec[v[18]] === 0xff ||\n    dec[v[19]] === 0xff ||\n    dec[v[20]] === 0xff ||\n    dec[v[21]] === 0xff ||\n    dec[v[22]] === 0xff ||\n    dec[v[23]] === 0xff ||\n    dec[v[24]] === 0xff ||\n    dec[v[25]] === 0xff\n  ) {\n    throw new Error(\"Invalid base32 character\");\n  }\n\n  const id = new Uint8Array(16);\n\n  // 6 bytes timestamp (48 bits)\n  id[0] = (dec[v[0]] << 5) | dec[v[1]];\n  id[1] = (dec[v[2]] << 3) | (dec[v[3]] >> 2);\n  id[2] = ((dec[v[3]] & 3) << 6) | (dec[v[4]] << 1) | (dec[v[5]] >> 4);\n  id[3] = ((dec[v[5]] & 15) << 4) | (dec[v[6]] >> 1);\n  id[4] = ((dec[v[6]] & 1) << 7) | (dec[v[7]] << 2) | (dec[v[8]] >> 3);\n  id[5] = ((dec[v[8]] & 7) << 5) | dec[v[9]];\n\n  // 10 bytes of entropy (80 bits)\n  id[6] = (dec[v[10]] << 3) | (dec[v[11]] >> 2);\n  id[7] = ((dec[v[11]] & 3) << 6) | (dec[v[12]] << 1) | (dec[v[13]] >> 4);\n  id[8] = ((dec[v[13]] & 15) << 4) | (dec[v[14]] >> 1);\n  id[9] = ((dec[v[14]] & 1) << 7) | (dec[v[15]] << 2) | (dec[v[16]] >> 3);\n  id[10] = ((dec[v[16]] & 7) << 5) | dec[v[17]];\n  id[11] = (dec[v[18]] << 3) | (dec[v[19]] >> 2);\n  id[12] = ((dec[v[19]] & 3) << 6) | (dec[v[20]] << 1) | (dec[v[21]] >> 4);\n  id[13] = ((dec[v[21]] & 15) << 4) | (dec[v[22]] >> 1);\n  id[14] = ((dec[v[22]] & 1) << 7) | (dec[v[23]] << 2) | (dec[v[24]] >> 3);\n  id[15] = ((dec[v[24]] & 7) << 5) | dec[v[25]];\n\n  return id;\n}\n", "import { stringify, v7 } from \"uuid\";\nimport { parseUUID } from \"../parse_uuid\";\nimport { encode, decode } from \"../base32\";\nimport { isValidPrefix } from \"../prefix\";\nimport {\n  EmptyPrefixError,\n  InvalidPrefixError,\n  InvalidSuffixCharacterError,\n  InvalidSuffixLengthError,\n  PrefixMismatchError,\n} from \"./error\";\n\nexport type TypeId<T> = string & { __type: T };\n\nexport function typeidUnboxed<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeId<T> {\n  if (!isValidPrefix(prefix)) {\n    throw new InvalidPrefixError(prefix);\n  }\n\n  let finalSuffix: string;\n  if (suffix) {\n    finalSuffix = suffix;\n  } else {\n    const buffer = new Uint8Array(16);\n    v7(undefined, buffer);\n    finalSuffix = encode(buffer);\n  }\n\n  if (finalSuffix.length !== 26) {\n    throw new InvalidSuffixLengthError(finalSuffix.length);\n  }\n\n  if (finalSuffix[0] > \"7\") {\n    throw new InvalidSuffixCharacterError(finalSuffix[0]);\n  }\n\n  // Validate the suffix by decoding it. If it's invalid, an error will be thrown.\n  decode(finalSuffix);\n\n  if (prefix === \"\") {\n    return finalSuffix as TypeId<T>;\n  } else {\n    return `${prefix}_${finalSuffix}` as TypeId<T>;\n  }\n}\n\n/**\n * Constructs a TypeId from a string representation, optionally validating against a provided prefix.\n * This function splits the input `typeId` string by an underscore `_` to separate the prefix and suffix.\n * If the `typeId` contains no underscore, it is assumed to be a suffix with an empty prefix.\n * If a `prefix` is provided, it must match the prefix part of the `typeId`, or an error is thrown.\n *\n * @param {string} typeId - The string representation of the TypeId to be parsed.\n * @param {T} [prefix] - An optional prefix to validate against the prefix in the `typeId`.\n * @returns {TypeId<T>} A new TypeId instance constructed from the parsed `typeId`.\n * @throws {Error} If the `typeId` format is invalid, the prefix is empty when there's a separator,\n *                 or there's a prefix mismatch when a `prefix` is provided.\n * @template T - A string literal type that extends string.\n */\nexport function fromString<T extends string>(\n  typeId: string,\n  prefix?: T\n): TypeId<T> {\n  let p;\n  let s;\n\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    p = \"\" as T;\n    s = typeId;\n  } else {\n    p = typeId.substring(0, underscoreIndex) as T;\n    s = typeId.substring(underscoreIndex + 1);\n\n    if (!p) {\n      throw new EmptyPrefixError(typeId);\n    }\n  }\n\n  if (!s) {\n    throw new InvalidSuffixLengthError(0);\n  }\n\n  if (prefix && p !== prefix) {\n    throw new PrefixMismatchError(prefix, p);\n  }\n\n  return typeidUnboxed(p, s);\n}\n\n/**\n * Parses a TypeId string into its prefix and suffix components.\n *\n * @param {TypeId<T>} typeId - The TypeId string to parse.\n * @returns {{ prefix: T; suffix: string }} An object containing the prefix and suffix of the TypeId.\n * @throws {Error} If the TypeId format is invalid (not exactly two parts separated by an underscore).\n *\n * @example\n * // For a valid TypeId 'example_00041061050r3gg28a1c60t3gf'\n * const { prefix, suffix } = parseTypeId('example_00041061050r3gg28a1c60t3gf');\n * console.log(prefix); // 'example'\n * console.log(suffix); // '00041061050r3gg28a1c60t3gf'\n *\n * @example\n * // Throws an error for invalid TypeId format\n * try {\n *   parseTypeId('invalidTypeId');\n * } catch (error) {\n *   console.error(error.message); // 'Invalid TypeId format: invalidTypeId'\n * }\n */\nexport function parseTypeId<T extends string>(\n  typeId: TypeId<T>\n): { prefix: T; suffix: string } {\n  return { prefix: getType(typeId), suffix: getSuffix(typeId) };\n}\n\n/**\n * Retrieves the prefix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the prefix.\n * @returns {T} The prefix of the TypeId.\n */\nexport function getType<T extends string>(typeId: TypeId<T>): T {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return \"\" as T;\n  }\n  return typeId.substring(0, underscoreIndex) as T;\n}\n\n/**\n * Retrieves the suffix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the suffix.\n * @returns {string} The suffix of the TypeId.\n */\nexport function getSuffix<T extends string>(typeId: TypeId<T>): string {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return typeId;\n  }\n  return typeId.substring(underscoreIndex + 1);\n}\n\nexport function toUUIDBytes<T extends string>(typeId: TypeId<T>): Uint8Array {\n  return decode(getSuffix(typeId));\n}\n\nexport function toUUID<T extends string>(typeId: TypeId<T>) {\n  return stringify(toUUIDBytes(typeId));\n}\n\nexport function fromUUIDBytes(\n  prefix: string,\n  bytes: Uint8Array\n): TypeId<typeof prefix> {\n  const suffix = encode(bytes);\n  return prefix\n    ? (`${prefix}_${suffix}` as TypeId<typeof prefix>)\n    : (suffix as TypeId<typeof prefix>);\n}\n\nexport function fromUUID<T extends string>(\n  uuid: string,\n  prefix?: T\n): TypeId<T> {\n  const suffix = encode(parseUUID(uuid));\n  return prefix ? (`${prefix}_${suffix}` as TypeId<T>) : (suffix as TypeId<T>);\n}\n", "export function isValidPrefix(str: string): boolean {\n  if (str.length > 63) {\n    return false;\n  }\n\n  let code;\n  let i;\n  let len;\n\n  for (i = 0, len = str.length; i < len; i += 1) {\n    code = str.charCodeAt(i);\n    const isLowerAtoZ = code > 96 && code < 123;\n    const isUnderscore = code === 95;\n\n    // first and last char of prefix can only be [a-z]\n    if ((i === 0 || i === len - 1) && !isLowerAtoZ) {\n      return false;\n    }\n\n    if (!(isLowerAtoZ || isUnderscore)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "export class InvalidPrefixError extends Error {\n  constructor(prefix: string) {\n    super(`Invalid prefix \"${prefix}\". Must be at most 63 ASCII letters [a-z_]`);\n    this.name = \"InvalidPrefixError\";\n  }\n}\n\nexport class PrefixMismatchError extends Error {\n  constructor(expected: string, actual: string) {\n    super(`Invalid TypeId. Prefix mismatch. Expected ${expected}, got ${actual}`);\n    this.name = \"PrefixMismatchError\";\n  }\n}\n\nexport class EmptyPrefixError extends Error {\n  constructor(typeId: string) {\n    super(`Invalid TypeId. Prefix cannot be empty when there's a separator: ${typeId}`);\n    this.name = \"EmptyPrefixError\";\n  }\n}\n\nexport class InvalidSuffixLengthError extends Error {\n  constructor(length: number) {\n    super(`Invalid length. Suffix should have 26 characters, got ${length}`);\n    this.name = \"InvalidSuffixLengthError\";\n  }\n}\n\nexport class InvalidSuffixCharacterError extends Error {\n  constructor(firstChar: string) {\n    super(`Invalid suffix. First character \"${firstChar}\" must be in the range [0-7]`);\n    this.name = \"InvalidSuffixCharacterError\";\n  }\n}\n\nexport class TypeIDConversionError extends Error {\n  constructor(actualPrefix: string, expectedPrefix: string) {\n    super(`Cannot convert TypeID of type ${actualPrefix} to type ${expectedPrefix}`);\n    this.name = \"TypeIDConversionError\";\n  }\n}\n", "import { LocalStorage, showToast, Toast } from \"@raycast/api\";\n\nexport interface HistoryEntry {\n  uuid: string;\n  timestamp: Date;\n  type: string;\n}\n\nexport enum UUIDType {\n  UUIDV4 = \"uuidV4\",\n  UUIDV5 = \"uuidV5\",\n  UUIDV7 = \"uuidV7\",\n  ULID = \"ulid\",\n  TYPEID = \"typeid\",\n}\n\nexport const addToHistory = async (uuid: string, type: UUIDType) => {\n  try {\n    let currentHistory = await LocalStorage.getItem(\"uuidHistory\");\n\n    if (!currentHistory) {\n      currentHistory = \"[]\";\n    }\n\n    if (typeof currentHistory !== \"string\") {\n      return;\n    }\n\n    const parsedHistory = JSON.parse(currentHistory);\n\n    parsedHistory.push({ uuid, timestamp: new Date(), type });\n\n    await LocalStorage.setItem(\"uuidHistory\", JSON.stringify(parsedHistory));\n  } catch (error) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Error saving history\",\n      message: \"Failed to save history to local storage\",\n    });\n  }\n};\n\nexport const getHistory = async (): Promise<HistoryEntry[]> => {\n  try {\n    const result = await LocalStorage.getItem(\"uuidHistory\");\n\n    if (!result) {\n      return [];\n    }\n\n    if (typeof result !== \"string\") {\n      throw new Error(\"Invalid data type: Expected a string\");\n    }\n\n    if (result) {\n      const history = JSON.parse(result);\n      return history;\n    } else {\n      return [];\n    }\n  } catch (error) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Error fetching history\",\n      message: \"Failed to retrieve history from local storage\",\n    });\n    return [];\n  }\n};\n\nexport const clearHistory = () => {\n  LocalStorage.removeItem(\"uuidHistory\")\n    .then(() => {\n      showToast({\n        style: Toast.Style.Success,\n        title: \"History Cleared\",\n        message: \"UUID history has been successfully cleared.\",\n      });\n    })\n    .catch((error) => {\n      console.error(\"Failed to clear history from local storage:\", error);\n      showToast({\n        style: Toast.Style.Failure,\n        title: \"Error clearing history\",\n        message: \"Failed to clear history from local storage\",\n      });\n    });\n};\n\nexport const deleteHistoryEntry = async (uuidToDelete: string) => {\n  try {\n    const result = await LocalStorage.getItem(\"uuidHistory\");\n\n    if (!result) {\n      return []; // No history found, return empty array\n    }\n\n    if (typeof result !== \"string\") {\n      throw new Error(\"Invalid data type: Expected a string\");\n    }\n\n    if (result) {\n      const history = JSON.parse(result) as HistoryEntry[];\n      const updatedHistory = history.filter((entry) => entry.uuid !== uuidToDelete);\n      await LocalStorage.setItem(\"uuidHistory\", JSON.stringify(updatedHistory));\n      return updatedHistory; // Return the updated history after deletion\n    } else {\n      return []; // No history found, return empty array\n    }\n  } catch (error) {\n    console.error(\"Failed to delete history entry:\", error);\n    return []; // Return empty array in case of error\n  }\n};\n", "import { addToHistory, UUIDType } from \"../uuidHistory\"; // Adjust the path based on your directory structure\n\nexport async function generateUuids(\n  uuidGenerator: () => string,\n  numberOfUuids: number,\n  upperCaseLetters = false,\n  type: UUIDType = UUIDType.UUIDV4,\n): Promise<string[]> {\n  const uuids = Array.from(Array(numberOfUuids)).map(() => {\n    const newUuid = uuidGenerator();\n    return upperCaseLetters ? newUuid.toUpperCase() : newUuid;\n  });\n\n  for (const uuid of uuids) {\n    await addToHistory(uuid, type);\n  }\n\n  return uuids;\n}\n"],
  "mappings": "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",
  "names": ["generateTypeID_exports", "__export", "generateTypeID_default", "__toCommonJS", "import_api", "regex_default", "validate", "uuid", "regex_default", "validate_default", "byteToHex", "i", "unsafeStringify", "arr", "offset", "stringify", "uuid", "validate_default", "stringify_default", "import_node_crypto", "rnds8Pool", "poolPtr", "rng", "crypto", "_seqLow", "_seqHigh", "_msecs", "v7", "options", "buf", "offset", "b", "rnds", "rng", "msecs", "seq", "seqHigh", "seqLow", "unsafeStringify", "v7_default", "parseUUID", "uuid", "v", "arr", "alphabet", "dec", "encode", "src", "dst", "decode", "s", "id", "isValidPrefix", "str", "code", "i", "len", "isLowerAtoZ", "isUnderscore", "InvalidPrefixError", "prefix", "PrefixMismatchError", "expected", "actual", "EmptyPrefixError", "typeId", "InvalidSuffixLengthError", "length", "InvalidSuffixCharacterError", "firstChar", "TypeIDConversionError", "actualPrefix", "expectedPrefix", "typeidUnboxed", "suffix", "finalSuffix", "buffer", "v7_default", "fromString", "p", "underscoreIndex", "getType", "typeId", "underscoreIndex", "getSuffix", "TypeID", "prefix", "suffix", "typeIdRaw", "typeidUnboxed", "getType", "getSuffix", "self", "TypeIDConversionError", "decode", "stringify", "str", "fromString", "bytes", "encode", "uuid", "parseUUID", "typeid", "import_api", "addToHistory", "uuid", "type", "currentHistory", "parsedHistory", "generateUuids", "uuidGenerator", "numberOfUuids", "upperCaseLetters", "type", "uuids", "newUuid", "uuid", "addToHistory", "UUID_MAX_NUMBER", "generateTypeID_default", "props", "prefix", "numberOfUUIDsToGenerate", "upperCaseLetters", "defaultAction", "parseableNumber", "uuids", "generateUuids", "typeid", "action", "successMessage", "e"]
}
