{
  "version": 3,
  "sources": ["../src/generateV5.tsx", "../node_modules/uuid/dist/esm/regex.js", "../node_modules/uuid/dist/esm/validate.js", "../node_modules/uuid/dist/esm/parse.js", "../node_modules/uuid/dist/esm/stringify.js", "../node_modules/uuid/dist/esm/v35.js", "../node_modules/uuid/dist/esm/sha1.js", "../node_modules/uuid/dist/esm/v5.js", "../src/uuidHistory.ts", "../src/utils/uuidUtils.ts"],
  "sourcesContent": ["import { showHUD, Clipboard, getPreferenceValues, showToast, Toast, LaunchProps } from \"@raycast/api\";\nimport { v5 as uuidV5, validate as uuidValidate } from \"uuid\";\n\nimport { generateUuids } from \"./utils/uuidUtils\";\nimport { UUIDType } from \"./uuidHistory\";\n\n// don't want to cause a heap error, so cap it \uD83D\uDE31\nconst UUID_MAX_NUMBER = 10000;\n\nexport default async (props: LaunchProps<{ arguments: Arguments.GenerateV5 }>) => {\n  let { numberOfUUIDsToGenerate } = props.arguments;\n  const { name } = props.arguments;\n  const { upperCaseLetters, uuidNamespace, defaultAction } = getPreferenceValues<Preferences.GenerateV5>();\n\n  if (!numberOfUUIDsToGenerate) {\n    numberOfUUIDsToGenerate = \"1\";\n  }\n\n  try {\n    const parseableNumber = parseInt(numberOfUUIDsToGenerate, 10);\n\n    if (isNaN(parseableNumber)) {\n      throw new Error(\"INVALID_NUMBER\");\n    }\n\n    if (!uuidValidate(uuidNamespace)) {\n      throw new Error(\"INVALID_NAMESPACE\");\n    }\n\n    // safe?\n    if (parseableNumber <= UUID_MAX_NUMBER) {\n      const uuids = await generateUuids(\n        () => uuidV5(name, uuidNamespace),\n        parseableNumber,\n        upperCaseLetters,\n        UUIDType.UUIDV5,\n      );\n\n      if (defaultAction === \"copy\") {\n        await Clipboard.copy(uuids.join(\"\\r\\n\"));\n      } else if (defaultAction === \"paste\") {\n        await Clipboard.paste(uuids.join(\"\\r\\n\"));\n      }\n      const action = defaultAction === \"copy\" ? \"Copied\" : \"Pasted\";\n      const successMessage = uuids.length > 1 ? `${action} ${uuids.length} new UUIDs.` : `${action} new UUID: ${uuids}`;\n      await showHUD(`\u2705 ${successMessage}`);\n    } else {\n      await showToast({\n        style: Toast.Style.Failure,\n        title: \"Too many UUIDs requested.\",\n        message: `${parseableNumber} exceeds maximum UUIDs of ${UUID_MAX_NUMBER}. Try a lower number.`,\n      });\n    }\n  } catch (e) {\n    switch ((e as { message: string }).message) {\n      case \"INVALID_NAMESPACE\":\n        await showToast({\n          style: Toast.Style.Failure,\n          title: \"Invalid namespace.\",\n          message: \"An invalid namespace has been defined. A namespace must be a valid UUID.\",\n        });\n        break;\n      case \"INVALID_NUMBER\":\n        await showToast({\n          style: Toast.Style.Failure,\n          title: \"Invalid number.\",\n          message: \"An invalid number has been provided. Try an actual number.\",\n        });\n        break;\n    }\n  }\n};\n", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n", "import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n", "import validate from './validate.js';\nfunction parse(uuid) {\n    if (!validate(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    let v;\n    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);\n}\nexport default parse;\n", "import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n", "import parse from './parse.js';\nimport { unsafeStringify } from './stringify.js';\nexport function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; ++i) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(version, hash, value, namespace, buf, offset) {\n    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;\n    const namespaceBytes = typeof namespace === 'string' ? parse(namespace) : namespace;\n    if (typeof namespace === 'string') {\n        namespace = parse(namespace);\n    }\n    if (namespace?.length !== 16) {\n        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n    let bytes = new Uint8Array(16 + valueBytes.length);\n    bytes.set(namespaceBytes);\n    bytes.set(valueBytes, namespaceBytes.length);\n    bytes = hash(bytes);\n    bytes[6] = (bytes[6] & 0x0f) | version;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(bytes);\n}\n", "import { createHash } from 'crypto';\nfunction sha1(bytes) {\n    if (Array.isArray(bytes)) {\n        bytes = Buffer.from(bytes);\n    }\n    else if (typeof bytes === 'string') {\n        bytes = Buffer.from(bytes, 'utf8');\n    }\n    return createHash('sha1').update(bytes).digest();\n}\nexport default sha1;\n", "import sha1 from './sha1.js';\nimport v35, { DNS, URL } from './v35.js';\nexport { DNS, URL } from './v35.js';\nfunction v5(value, namespace, buf, offset) {\n    return v35(0x50, sha1, value, namespace, buf, offset);\n}\nv5.DNS = DNS;\nv5.URL = URL;\nexport default v5;\n", "import { LocalStorage, showToast, Toast } from \"@raycast/api\";\n\nexport interface HistoryEntry {\n  uuid: string;\n  timestamp: Date;\n  type: string;\n}\n\nexport enum UUIDType {\n  UUIDV4 = \"uuidV4\",\n  UUIDV5 = \"uuidV5\",\n  UUIDV7 = \"uuidV7\",\n  ULID = \"ulid\",\n  TYPEID = \"typeid\",\n}\n\nexport const addToHistory = async (uuid: string, type: UUIDType) => {\n  try {\n    let currentHistory = await LocalStorage.getItem(\"uuidHistory\");\n\n    if (!currentHistory) {\n      currentHistory = \"[]\";\n    }\n\n    if (typeof currentHistory !== \"string\") {\n      return;\n    }\n\n    const parsedHistory = JSON.parse(currentHistory);\n\n    parsedHistory.push({ uuid, timestamp: new Date(), type });\n\n    await LocalStorage.setItem(\"uuidHistory\", JSON.stringify(parsedHistory));\n  } catch (error) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Error saving history\",\n      message: \"Failed to save history to local storage\",\n    });\n  }\n};\n\nexport const getHistory = async (): Promise<HistoryEntry[]> => {\n  try {\n    const result = await LocalStorage.getItem(\"uuidHistory\");\n\n    if (!result) {\n      return [];\n    }\n\n    if (typeof result !== \"string\") {\n      throw new Error(\"Invalid data type: Expected a string\");\n    }\n\n    if (result) {\n      const history = JSON.parse(result);\n      return history;\n    } else {\n      return [];\n    }\n  } catch (error) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Error fetching history\",\n      message: \"Failed to retrieve history from local storage\",\n    });\n    return [];\n  }\n};\n\nexport const clearHistory = () => {\n  LocalStorage.removeItem(\"uuidHistory\")\n    .then(() => {\n      showToast({\n        style: Toast.Style.Success,\n        title: \"History Cleared\",\n        message: \"UUID history has been successfully cleared.\",\n      });\n    })\n    .catch((error) => {\n      console.error(\"Failed to clear history from local storage:\", error);\n      showToast({\n        style: Toast.Style.Failure,\n        title: \"Error clearing history\",\n        message: \"Failed to clear history from local storage\",\n      });\n    });\n};\n\nexport const deleteHistoryEntry = async (uuidToDelete: string) => {\n  try {\n    const result = await LocalStorage.getItem(\"uuidHistory\");\n\n    if (!result) {\n      return []; // No history found, return empty array\n    }\n\n    if (typeof result !== \"string\") {\n      throw new Error(\"Invalid data type: Expected a string\");\n    }\n\n    if (result) {\n      const history = JSON.parse(result) as HistoryEntry[];\n      const updatedHistory = history.filter((entry) => entry.uuid !== uuidToDelete);\n      await LocalStorage.setItem(\"uuidHistory\", JSON.stringify(updatedHistory));\n      return updatedHistory; // Return the updated history after deletion\n    } else {\n      return []; // No history found, return empty array\n    }\n  } catch (error) {\n    console.error(\"Failed to delete history entry:\", error);\n    return []; // Return empty array in case of error\n  }\n};\n", "import { addToHistory, UUIDType } from \"../uuidHistory\"; // Adjust the path based on your directory structure\n\nexport async function generateUuids(\n  uuidGenerator: () => string,\n  numberOfUuids: number,\n  upperCaseLetters = false,\n  type: UUIDType = UUIDType.UUIDV4,\n): Promise<string[]> {\n  const uuids = Array.from(Array(numberOfUuids)).map(() => {\n    const newUuid = uuidGenerator();\n    return upperCaseLetters ? newUuid.toUpperCase() : newUuid;\n  });\n\n  for (const uuid of uuids) {\n    await addToHistory(uuid, type);\n  }\n\n  return uuids;\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAuF,wBCAvF,IAAOC,EAAQ,2JCCf,SAASC,EAASC,EAAM,CACpB,OAAO,OAAOA,GAAS,UAAYC,EAAM,KAAKD,CAAI,CACtD,CACA,IAAOE,EAAQH,ECHf,SAASI,EAAMC,EAAM,CACjB,GAAI,CAACC,EAASD,CAAI,EACd,MAAM,UAAU,cAAc,EAElC,IAAIE,EACJ,OAAO,WAAW,IAAIA,EAAI,SAASF,EAAK,MAAM,EAAG,CAAC,EAAG,EAAE,KAAO,GAAKE,IAAM,GAAM,IAAOA,IAAM,EAAK,IAAMA,EAAI,KAAOA,EAAI,SAASF,EAAK,MAAM,EAAG,EAAE,EAAG,EAAE,KAAO,EAAGE,EAAI,KAAOA,EAAI,SAASF,EAAK,MAAM,GAAI,EAAE,EAAG,EAAE,KAAO,EAAGE,EAAI,KAAOA,EAAI,SAASF,EAAK,MAAM,GAAI,EAAE,EAAG,EAAE,KAAO,EAAGE,EAAI,KAAQA,EAAI,SAASF,EAAK,MAAM,GAAI,EAAE,EAAG,EAAE,GAAK,cAAiB,IAAOE,EAAI,WAAe,IAAOA,IAAM,GAAM,IAAOA,IAAM,GAAM,IAAOA,IAAM,EAAK,IAAMA,EAAI,GAAI,CACvb,CACA,IAAOC,EAAQJ,ECPf,IAAMK,EAAY,CAAC,EACnB,QAASC,EAAI,EAAGA,EAAI,IAAK,EAAEA,EACvBD,EAAU,MAAMC,EAAI,KAAO,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC,EAE7C,SAASC,EAAgBC,EAAKC,EAAS,EAAG,CAC7C,OAAQJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EAC7BJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzBJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzBJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzB,IACAJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzBJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzB,IACAJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzBJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzB,IACAJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzBJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzB,IACAJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,EAC1BJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,EAC1BJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,EAC1BJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,EAC1BJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,EAC1BJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,GAAG,YAAY,CACjD,CCxBO,SAASC,EAAcC,EAAK,CAC/BA,EAAM,SAAS,mBAAmBA,CAAG,CAAC,EACtC,IAAMC,EAAQ,IAAI,WAAWD,EAAI,MAAM,EACvC,QAASE,EAAI,EAAGA,EAAIF,EAAI,OAAQ,EAAEE,EAC9BD,EAAMC,CAAC,EAAIF,EAAI,WAAWE,CAAC,EAE/B,OAAOD,CACX,CACO,IAAME,EAAM,uCACNC,EAAM,uCACJ,SAARC,EAAqBC,EAASC,EAAMC,EAAOC,EAAWC,EAAKC,EAAQ,CACtE,IAAMC,EAAa,OAAOJ,GAAU,SAAWT,EAAcS,CAAK,EAAIA,EAChEK,EAAiB,OAAOJ,GAAc,SAAWK,EAAML,CAAS,EAAIA,EAI1E,GAHI,OAAOA,GAAc,WACrBA,EAAYK,EAAML,CAAS,GAE3BA,GAAW,SAAW,GACtB,MAAM,UAAU,kEAAkE,EAEtF,IAAIR,EAAQ,IAAI,WAAW,GAAKW,EAAW,MAAM,EAMjD,GALAX,EAAM,IAAIY,CAAc,EACxBZ,EAAM,IAAIW,EAAYC,EAAe,MAAM,EAC3CZ,EAAQM,EAAKN,CAAK,EAClBA,EAAM,CAAC,EAAKA,EAAM,CAAC,EAAI,GAAQK,EAC/BL,EAAM,CAAC,EAAKA,EAAM,CAAC,EAAI,GAAQ,IAC3BS,EAAK,CACLC,EAASA,GAAU,EACnB,QAAST,EAAI,EAAGA,EAAI,GAAI,EAAEA,EACtBQ,EAAIC,EAAST,CAAC,EAAID,EAAMC,CAAC,EAE7B,OAAOQ,CACX,CACA,OAAOK,EAAgBd,CAAK,CAChC,CCnCA,IAAAe,EAA2B,kBAC3B,SAASC,EAAKC,EAAO,CACjB,OAAI,MAAM,QAAQA,CAAK,EACnBA,EAAQ,OAAO,KAAKA,CAAK,EAEpB,OAAOA,GAAU,WACtBA,EAAQ,OAAO,KAAKA,EAAO,MAAM,MAE9B,cAAW,MAAM,EAAE,OAAOA,CAAK,EAAE,OAAO,CACnD,CACA,IAAOC,EAAQF,ECPf,SAASG,EAAGC,EAAOC,EAAWC,EAAKC,EAAQ,CACvC,OAAOC,EAAI,GAAMC,EAAML,EAAOC,EAAWC,EAAKC,CAAM,CACxD,CACAJ,EAAG,IAAMO,EACTP,EAAG,IAAMQ,EACT,IAAOC,EAAQT,ECRf,IAAAU,EAA+C,wBAgBxC,IAAMC,EAAe,MAAOC,EAAcC,IAAmB,CAClE,GAAI,CACF,IAAIC,EAAiB,MAAM,eAAa,QAAQ,aAAa,EAM7D,GAJKA,IACHA,EAAiB,MAGf,OAAOA,GAAmB,SAC5B,OAGF,IAAMC,EAAgB,KAAK,MAAMD,CAAc,EAE/CC,EAAc,KAAK,CAAE,KAAAH,EAAM,UAAW,IAAI,KAAQ,KAAAC,CAAK,CAAC,EAExD,MAAM,eAAa,QAAQ,cAAe,KAAK,UAAUE,CAAa,CAAC,CACzE,MAAgB,CACd,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,QACnB,MAAO,uBACP,QAAS,yCACX,CAAC,CACH,CACF,ECtCA,eAAsBC,EACpBC,EACAC,EACAC,EAAmB,GACnBC,WACmB,CACnB,IAAMC,EAAQ,MAAM,KAAK,MAAMH,CAAa,CAAC,EAAE,IAAI,IAAM,CACvD,IAAMI,EAAUL,EAAc,EAC9B,OAAOE,EAAmBG,EAAQ,YAAY,EAAIA,CACpD,CAAC,EAED,QAAWC,KAAQF,EACjB,MAAMG,EAAaD,EAAMH,CAAI,EAG/B,OAAOC,CACT,CTXA,IAAMI,EAAkB,IAEjBC,EAAQ,MAAOC,GAA4D,CAChF,GAAI,CAAE,wBAAAC,CAAwB,EAAID,EAAM,UAClC,CAAE,KAAAE,CAAK,EAAIF,EAAM,UACjB,CAAE,iBAAAG,EAAkB,cAAAC,EAAe,cAAAC,CAAc,KAAI,uBAA4C,EAElGJ,IACHA,EAA0B,KAG5B,GAAI,CACF,IAAMK,EAAkB,SAASL,EAAyB,EAAE,EAE5D,GAAI,MAAMK,CAAe,EACvB,MAAM,IAAI,MAAM,gBAAgB,EAGlC,GAAI,CAACC,EAAaH,CAAa,EAC7B,MAAM,IAAI,MAAM,mBAAmB,EAIrC,GAAIE,GAAmBR,EAAiB,CACtC,IAAMU,EAAQ,MAAMC,EAClB,IAAMC,EAAOR,EAAME,CAAa,EAChCE,EACAH,UAEF,EAEIE,IAAkB,OACpB,MAAM,YAAU,KAAKG,EAAM,KAAK;AAAA,CAAM,CAAC,EAC9BH,IAAkB,SAC3B,MAAM,YAAU,MAAMG,EAAM,KAAK;AAAA,CAAM,CAAC,EAE1C,IAAMG,EAASN,IAAkB,OAAS,SAAW,SAC/CO,EAAiBJ,EAAM,OAAS,EAAI,GAAGG,CAAM,IAAIH,EAAM,MAAM,cAAgB,GAAGG,CAAM,cAAcH,CAAK,GAC/G,QAAM,WAAQ,UAAKI,CAAc,EAAE,CACrC,MACE,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,QACnB,MAAO,4BACP,QAAS,GAAGN,CAAe,6BAA6BR,CAAe,uBACzE,CAAC,CAEL,OAASe,EAAG,CACV,OAASA,EAA0B,QAAS,CAC1C,IAAK,oBACH,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,QACnB,MAAO,qBACP,QAAS,0EACX,CAAC,EACD,MACF,IAAK,iBACH,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,QACnB,MAAO,kBACP,QAAS,4DACX,CAAC,EACD,KACJ,CACF,CACF",
  "names": ["generateV5_exports", "__export", "generateV5_default", "__toCommonJS", "import_api", "regex_default", "validate", "uuid", "regex_default", "validate_default", "parse", "uuid", "validate_default", "v", "parse_default", "byteToHex", "i", "unsafeStringify", "arr", "offset", "stringToBytes", "str", "bytes", "i", "DNS", "URL", "v35", "version", "hash", "value", "namespace", "buf", "offset", "valueBytes", "namespaceBytes", "parse_default", "unsafeStringify", "import_crypto", "sha1", "bytes", "sha1_default", "v5", "value", "namespace", "buf", "offset", "v35", "sha1_default", "DNS", "URL", "v5_default", "import_api", "addToHistory", "uuid", "type", "currentHistory", "parsedHistory", "generateUuids", "uuidGenerator", "numberOfUuids", "upperCaseLetters", "type", "uuids", "newUuid", "uuid", "addToHistory", "UUID_MAX_NUMBER", "generateV5_default", "props", "numberOfUUIDsToGenerate", "name", "upperCaseLetters", "uuidNamespace", "defaultAction", "parseableNumber", "validate_default", "uuids", "generateUuids", "v5_default", "action", "successMessage", "e"]
}
