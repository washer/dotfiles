{
  "version": 3,
  "sources": ["../src/parseTypeID.ts", "../node_modules/typeid-js/node_modules/uuid/dist/esm-node/regex.js", "../node_modules/typeid-js/node_modules/uuid/dist/esm-node/validate.js", "../node_modules/typeid-js/node_modules/uuid/dist/esm-node/stringify.js", "../node_modules/typeid-js/node_modules/uuid/dist/esm-node/rng.js", "../node_modules/typeid-js/node_modules/uuid/dist/esm-node/v7.js", "../node_modules/typeid-js/src/typeid.ts", "../node_modules/typeid-js/src/parse_uuid.ts", "../node_modules/typeid-js/src/base32.ts", "../node_modules/typeid-js/src/unboxed/typeid.ts", "../node_modules/typeid-js/src/prefix.ts", "../node_modules/typeid-js/src/unboxed/error.ts"],
  "sourcesContent": ["import { Clipboard, getPreferenceValues, LaunchProps, showHUD, showToast, Toast } from \"@raycast/api\";\nimport { fromString, toUUID } from \"typeid-js\";\n\nexport default async (props: LaunchProps<{ arguments: { typeID: string } }>) => {\n  const { typeID } = props.arguments;\n  if (!typeID) {\n    await showToast({ style: Toast.Style.Failure, title: \"No TypeID(s) provided\" });\n    return;\n  }\n\n  const { defaultAction } = getPreferenceValues<{ defaultAction: \"copy\" | \"paste\" }>();\n\n  try {\n    const typeIdInstance = fromString(typeID);\n    const uuid = toUUID(typeIdInstance);\n\n    if (defaultAction === \"copy\") {\n      await Clipboard.copy(uuid);\n    } else if (defaultAction === \"paste\") {\n      await Clipboard.paste(uuid);\n    }\n\n    const action = defaultAction === \"copy\" ? \"Copied\" : \"Pasted\";\n    await showHUD(`\u2705 ${action} decoded UUID: ${uuid}`);\n  } catch (error) {\n    await showToast({ style: Toast.Style.Failure, title: \"Decoding Error\", message: String(error) });\n  }\n};\n", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;", "import REGEX from './regex.js';\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;", "import validate from './validate.js';\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nexport default stringify;", "import crypto from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}", "import rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nlet _seqLow = null;\nlet _seqHigh = null;\nlet _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  const rnds = options.random || (options.rng || rng)();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  const msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  let seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  let seqHigh = _seqHigh;\n  let seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || unsafeStringify(b);\n}\nexport default v7;", "import { stringify } from \"uuid\";\nimport { parseUUID } from \"./parse_uuid\";\nimport { encode, decode } from \"./base32\";\nimport {\n  typeidUnboxed,\n  getSuffix,\n  getType,\n  fromString,\n} from \"./unboxed/typeid\";\nimport { TypeIDConversionError } from \"./unboxed/error\";\n\nexport class TypeID<const T extends string> {\n  constructor(private prefix: T, private suffix: string = \"\") {\n    const typeIdRaw = typeidUnboxed(prefix, suffix);\n\n    this.prefix = getType(typeIdRaw);\n    this.suffix = getSuffix(typeIdRaw);\n  }\n\n  public getType(): T {\n    return this.prefix;\n  }\n\n  public getSuffix(): string {\n    return this.suffix;\n  }\n\n  public asType<const U extends string>(prefix: U): TypeID<U> {\n    const self = this as unknown as TypeID<U>;\n    if (self.prefix !== prefix) {\n      throw new TypeIDConversionError(self.prefix, prefix);\n    }\n    return self;\n  }\n\n  public toUUIDBytes(): Uint8Array {\n    return decode(this.suffix);\n  }\n\n  public toUUID(): string {\n    return stringify(this.toUUIDBytes());\n  }\n\n  public toString(): T extends \"\" ? string : `${T}_${string}` {\n    if (this.prefix === \"\") {\n      return this.suffix as T extends \"\" ? string : `${T}_${string}`;\n    }\n    return `${this.prefix}_${this.suffix}` as T extends \"\" ? string : `${T}_${string}`;\n  }\n\n  static fromString<const T extends string>(\n    str: string,\n    prefix?: T\n  ): TypeID<T> {\n    const typeIdRaw = fromString(str, prefix);\n\n    return new TypeID<T>(getType(typeIdRaw) as T, getSuffix(typeIdRaw));\n  }\n\n  static fromUUIDBytes<const T extends string>(\n    prefix: T,\n    bytes: Uint8Array\n  ): TypeID<T> {\n    const suffix = encode(bytes);\n    return new TypeID(prefix, suffix);\n  }\n\n  static fromUUID<const T extends string>(prefix: T, uuid: string): TypeID<T> {\n    const suffix = encode(parseUUID(uuid));\n    return new TypeID(prefix, suffix);\n  }\n}\n\nexport function typeid<T extends string>(): TypeID<\"\">;\nexport function typeid<T extends string>(prefix: T): TypeID<T>;\nexport function typeid<T extends string>(prefix: T, suffix: string): TypeID<T>;\nexport function typeid<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeID<T> {\n  return new TypeID(prefix, suffix);\n}\n", "/* eslint-disable no-bitwise */\nexport function parseUUID(uuid: string) {\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Block 1\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = (v >>> 16) & 0xff;\n  arr[2] = (v >>> 8) & 0xff;\n  arr[3] = v & 0xff;\n\n  // Block 2\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Block 3\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Block 4\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Block 5\n  arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff;\n  arr[11] = (v / 0x100000000) & 0xff;\n  arr[12] = (v >>> 24) & 0xff;\n  arr[13] = (v >>> 16) & 0xff;\n  arr[14] = (v >>> 8) & 0xff;\n  arr[15] = v & 0xff;\n\n  return arr;\n}\n", "/* eslint-disable no-bitwise */\nconst alphabet: string = \"0123456789abcdefghjkmnpqrstvwxyz\";\n\n// Decoding table\nconst dec: Uint8Array = new Uint8Array([\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03,\n  0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n  0x11, 0xff, 0x12, 0x13, 0xff, 0x14, 0x15, 0xff, 0x16, 0x17, 0x18, 0x19, 0x1a,\n  0xff, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n]);\n\nexport function encode(src: Uint8Array): string {\n  const dst: string[] = new Array(26).fill(\"\");\n\n  if (src.length !== 16) {\n    throw new Error(\n      `Invalid length. Expected 16 bytes, got ${src.length}. Input: ${src}`\n    );\n  }\n\n  // 10 byte timestamp\n  dst[0] = alphabet[(src[0] & 224) >> 5];\n  dst[1] = alphabet[src[0] & 31];\n  dst[2] = alphabet[(src[1] & 248) >> 3];\n  dst[3] = alphabet[((src[1] & 7) << 2) | ((src[2] & 192) >> 6)];\n  dst[4] = alphabet[(src[2] & 62) >> 1];\n  dst[5] = alphabet[((src[2] & 1) << 4) | ((src[3] & 240) >> 4)];\n  dst[6] = alphabet[((src[3] & 15) << 1) | ((src[4] & 128) >> 7)];\n  dst[7] = alphabet[(src[4] & 124) >> 2];\n  dst[8] = alphabet[((src[4] & 3) << 3) | ((src[5] & 224) >> 5)];\n  dst[9] = alphabet[src[5] & 31];\n\n  // 16 bytes of randomness\n  dst[10] = alphabet[(src[6] & 248) >> 3];\n  dst[11] = alphabet[((src[6] & 7) << 2) | ((src[7] & 192) >> 6)];\n  dst[12] = alphabet[(src[7] & 62) >> 1];\n  dst[13] = alphabet[((src[7] & 1) << 4) | ((src[8] & 240) >> 4)];\n  dst[14] = alphabet[((src[8] & 15) << 1) | ((src[9] & 128) >> 7)];\n  dst[15] = alphabet[(src[9] & 124) >> 2];\n  dst[16] = alphabet[((src[9] & 3) << 3) | ((src[10] & 224) >> 5)];\n  dst[17] = alphabet[src[10] & 31];\n  dst[18] = alphabet[(src[11] & 248) >> 3];\n  dst[19] = alphabet[((src[11] & 7) << 2) | ((src[12] & 192) >> 6)];\n  dst[20] = alphabet[(src[12] & 62) >> 1];\n  dst[21] = alphabet[((src[12] & 1) << 4) | ((src[13] & 240) >> 4)];\n  dst[22] = alphabet[((src[13] & 15) << 1) | ((src[14] & 128) >> 7)];\n  dst[23] = alphabet[(src[14] & 124) >> 2];\n  dst[24] = alphabet[((src[14] & 3) << 3) | ((src[15] & 224) >> 5)];\n  dst[25] = alphabet[src[15] & 31];\n\n  return dst.join(\"\");\n}\n\nexport function decode(s: string): Uint8Array {\n  if (s.length !== 26) {\n    throw new Error(\n      `Invalid length. Expected 26 bytes, got ${s.length}. Input: ${s}`\n    );\n  }\n\n  const encoder = new TextEncoder();\n  const v: Uint8Array = encoder.encode(s);\n\n  // Check if all the characters are part of the expected base32 character set.\n  if (\n    dec[v[0]] === 0xff ||\n    dec[v[1]] === 0xff ||\n    dec[v[2]] === 0xff ||\n    dec[v[3]] === 0xff ||\n    dec[v[4]] === 0xff ||\n    dec[v[5]] === 0xff ||\n    dec[v[6]] === 0xff ||\n    dec[v[7]] === 0xff ||\n    dec[v[8]] === 0xff ||\n    dec[v[9]] === 0xff ||\n    dec[v[10]] === 0xff ||\n    dec[v[11]] === 0xff ||\n    dec[v[12]] === 0xff ||\n    dec[v[13]] === 0xff ||\n    dec[v[14]] === 0xff ||\n    dec[v[15]] === 0xff ||\n    dec[v[16]] === 0xff ||\n    dec[v[17]] === 0xff ||\n    dec[v[18]] === 0xff ||\n    dec[v[19]] === 0xff ||\n    dec[v[20]] === 0xff ||\n    dec[v[21]] === 0xff ||\n    dec[v[22]] === 0xff ||\n    dec[v[23]] === 0xff ||\n    dec[v[24]] === 0xff ||\n    dec[v[25]] === 0xff\n  ) {\n    throw new Error(\"Invalid base32 character\");\n  }\n\n  const id = new Uint8Array(16);\n\n  // 6 bytes timestamp (48 bits)\n  id[0] = (dec[v[0]] << 5) | dec[v[1]];\n  id[1] = (dec[v[2]] << 3) | (dec[v[3]] >> 2);\n  id[2] = ((dec[v[3]] & 3) << 6) | (dec[v[4]] << 1) | (dec[v[5]] >> 4);\n  id[3] = ((dec[v[5]] & 15) << 4) | (dec[v[6]] >> 1);\n  id[4] = ((dec[v[6]] & 1) << 7) | (dec[v[7]] << 2) | (dec[v[8]] >> 3);\n  id[5] = ((dec[v[8]] & 7) << 5) | dec[v[9]];\n\n  // 10 bytes of entropy (80 bits)\n  id[6] = (dec[v[10]] << 3) | (dec[v[11]] >> 2);\n  id[7] = ((dec[v[11]] & 3) << 6) | (dec[v[12]] << 1) | (dec[v[13]] >> 4);\n  id[8] = ((dec[v[13]] & 15) << 4) | (dec[v[14]] >> 1);\n  id[9] = ((dec[v[14]] & 1) << 7) | (dec[v[15]] << 2) | (dec[v[16]] >> 3);\n  id[10] = ((dec[v[16]] & 7) << 5) | dec[v[17]];\n  id[11] = (dec[v[18]] << 3) | (dec[v[19]] >> 2);\n  id[12] = ((dec[v[19]] & 3) << 6) | (dec[v[20]] << 1) | (dec[v[21]] >> 4);\n  id[13] = ((dec[v[21]] & 15) << 4) | (dec[v[22]] >> 1);\n  id[14] = ((dec[v[22]] & 1) << 7) | (dec[v[23]] << 2) | (dec[v[24]] >> 3);\n  id[15] = ((dec[v[24]] & 7) << 5) | dec[v[25]];\n\n  return id;\n}\n", "import { stringify, v7 } from \"uuid\";\nimport { parseUUID } from \"../parse_uuid\";\nimport { encode, decode } from \"../base32\";\nimport { isValidPrefix } from \"../prefix\";\nimport {\n  EmptyPrefixError,\n  InvalidPrefixError,\n  InvalidSuffixCharacterError,\n  InvalidSuffixLengthError,\n  PrefixMismatchError,\n} from \"./error\";\n\nexport type TypeId<T> = string & { __type: T };\n\nexport function typeidUnboxed<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeId<T> {\n  if (!isValidPrefix(prefix)) {\n    throw new InvalidPrefixError(prefix);\n  }\n\n  let finalSuffix: string;\n  if (suffix) {\n    finalSuffix = suffix;\n  } else {\n    const buffer = new Uint8Array(16);\n    v7(undefined, buffer);\n    finalSuffix = encode(buffer);\n  }\n\n  if (finalSuffix.length !== 26) {\n    throw new InvalidSuffixLengthError(finalSuffix.length);\n  }\n\n  if (finalSuffix[0] > \"7\") {\n    throw new InvalidSuffixCharacterError(finalSuffix[0]);\n  }\n\n  // Validate the suffix by decoding it. If it's invalid, an error will be thrown.\n  decode(finalSuffix);\n\n  if (prefix === \"\") {\n    return finalSuffix as TypeId<T>;\n  } else {\n    return `${prefix}_${finalSuffix}` as TypeId<T>;\n  }\n}\n\n/**\n * Constructs a TypeId from a string representation, optionally validating against a provided prefix.\n * This function splits the input `typeId` string by an underscore `_` to separate the prefix and suffix.\n * If the `typeId` contains no underscore, it is assumed to be a suffix with an empty prefix.\n * If a `prefix` is provided, it must match the prefix part of the `typeId`, or an error is thrown.\n *\n * @param {string} typeId - The string representation of the TypeId to be parsed.\n * @param {T} [prefix] - An optional prefix to validate against the prefix in the `typeId`.\n * @returns {TypeId<T>} A new TypeId instance constructed from the parsed `typeId`.\n * @throws {Error} If the `typeId` format is invalid, the prefix is empty when there's a separator,\n *                 or there's a prefix mismatch when a `prefix` is provided.\n * @template T - A string literal type that extends string.\n */\nexport function fromString<T extends string>(\n  typeId: string,\n  prefix?: T\n): TypeId<T> {\n  let p;\n  let s;\n\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    p = \"\" as T;\n    s = typeId;\n  } else {\n    p = typeId.substring(0, underscoreIndex) as T;\n    s = typeId.substring(underscoreIndex + 1);\n\n    if (!p) {\n      throw new EmptyPrefixError(typeId);\n    }\n  }\n\n  if (!s) {\n    throw new InvalidSuffixLengthError(0);\n  }\n\n  if (prefix && p !== prefix) {\n    throw new PrefixMismatchError(prefix, p);\n  }\n\n  return typeidUnboxed(p, s);\n}\n\n/**\n * Parses a TypeId string into its prefix and suffix components.\n *\n * @param {TypeId<T>} typeId - The TypeId string to parse.\n * @returns {{ prefix: T; suffix: string }} An object containing the prefix and suffix of the TypeId.\n * @throws {Error} If the TypeId format is invalid (not exactly two parts separated by an underscore).\n *\n * @example\n * // For a valid TypeId 'example_00041061050r3gg28a1c60t3gf'\n * const { prefix, suffix } = parseTypeId('example_00041061050r3gg28a1c60t3gf');\n * console.log(prefix); // 'example'\n * console.log(suffix); // '00041061050r3gg28a1c60t3gf'\n *\n * @example\n * // Throws an error for invalid TypeId format\n * try {\n *   parseTypeId('invalidTypeId');\n * } catch (error) {\n *   console.error(error.message); // 'Invalid TypeId format: invalidTypeId'\n * }\n */\nexport function parseTypeId<T extends string>(\n  typeId: TypeId<T>\n): { prefix: T; suffix: string } {\n  return { prefix: getType(typeId), suffix: getSuffix(typeId) };\n}\n\n/**\n * Retrieves the prefix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the prefix.\n * @returns {T} The prefix of the TypeId.\n */\nexport function getType<T extends string>(typeId: TypeId<T>): T {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return \"\" as T;\n  }\n  return typeId.substring(0, underscoreIndex) as T;\n}\n\n/**\n * Retrieves the suffix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the suffix.\n * @returns {string} The suffix of the TypeId.\n */\nexport function getSuffix<T extends string>(typeId: TypeId<T>): string {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return typeId;\n  }\n  return typeId.substring(underscoreIndex + 1);\n}\n\nexport function toUUIDBytes<T extends string>(typeId: TypeId<T>): Uint8Array {\n  return decode(getSuffix(typeId));\n}\n\nexport function toUUID<T extends string>(typeId: TypeId<T>) {\n  return stringify(toUUIDBytes(typeId));\n}\n\nexport function fromUUIDBytes(\n  prefix: string,\n  bytes: Uint8Array\n): TypeId<typeof prefix> {\n  const suffix = encode(bytes);\n  return prefix\n    ? (`${prefix}_${suffix}` as TypeId<typeof prefix>)\n    : (suffix as TypeId<typeof prefix>);\n}\n\nexport function fromUUID<T extends string>(\n  uuid: string,\n  prefix?: T\n): TypeId<T> {\n  const suffix = encode(parseUUID(uuid));\n  return prefix ? (`${prefix}_${suffix}` as TypeId<T>) : (suffix as TypeId<T>);\n}\n", "export function isValidPrefix(str: string): boolean {\n  if (str.length > 63) {\n    return false;\n  }\n\n  let code;\n  let i;\n  let len;\n\n  for (i = 0, len = str.length; i < len; i += 1) {\n    code = str.charCodeAt(i);\n    const isLowerAtoZ = code > 96 && code < 123;\n    const isUnderscore = code === 95;\n\n    // first and last char of prefix can only be [a-z]\n    if ((i === 0 || i === len - 1) && !isLowerAtoZ) {\n      return false;\n    }\n\n    if (!(isLowerAtoZ || isUnderscore)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "export class InvalidPrefixError extends Error {\n  constructor(prefix: string) {\n    super(`Invalid prefix \"${prefix}\". Must be at most 63 ASCII letters [a-z_]`);\n    this.name = \"InvalidPrefixError\";\n  }\n}\n\nexport class PrefixMismatchError extends Error {\n  constructor(expected: string, actual: string) {\n    super(`Invalid TypeId. Prefix mismatch. Expected ${expected}, got ${actual}`);\n    this.name = \"PrefixMismatchError\";\n  }\n}\n\nexport class EmptyPrefixError extends Error {\n  constructor(typeId: string) {\n    super(`Invalid TypeId. Prefix cannot be empty when there's a separator: ${typeId}`);\n    this.name = \"EmptyPrefixError\";\n  }\n}\n\nexport class InvalidSuffixLengthError extends Error {\n  constructor(length: number) {\n    super(`Invalid length. Suffix should have 26 characters, got ${length}`);\n    this.name = \"InvalidSuffixLengthError\";\n  }\n}\n\nexport class InvalidSuffixCharacterError extends Error {\n  constructor(firstChar: string) {\n    super(`Invalid suffix. First character \"${firstChar}\" must be in the range [0-7]`);\n    this.name = \"InvalidSuffixCharacterError\";\n  }\n}\n\nexport class TypeIDConversionError extends Error {\n  constructor(actualPrefix: string, expectedPrefix: string) {\n    super(`Cannot convert TypeID of type ${actualPrefix} to type ${expectedPrefix}`);\n    this.name = \"TypeIDConversionError\";\n  }\n}\n"],
  "mappings": "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",
  "names": ["parseTypeID_exports", "__export", "parseTypeID_default", "__toCommonJS", "import_api", "regex_default", "validate", "uuid", "regex_default", "validate_default", "byteToHex", "i", "unsafeStringify", "arr", "offset", "stringify", "uuid", "validate_default", "stringify_default", "import_node_crypto", "rnds8Pool", "poolPtr", "rng", "crypto", "_seqLow", "_seqHigh", "_msecs", "v7", "options", "buf", "offset", "i", "b", "rnds", "rng", "msecs", "seq", "seqHigh", "seqLow", "unsafeStringify", "v7_default", "alphabet", "dec", "encode", "src", "dst", "decode", "s", "v", "id", "isValidPrefix", "str", "code", "i", "len", "isLowerAtoZ", "isUnderscore", "InvalidPrefixError", "prefix", "PrefixMismatchError", "expected", "actual", "EmptyPrefixError", "typeId", "InvalidSuffixLengthError", "length", "InvalidSuffixCharacterError", "firstChar", "typeidUnboxed", "prefix", "suffix", "isValidPrefix", "InvalidPrefixError", "finalSuffix", "buffer", "v7_default", "encode", "InvalidSuffixLengthError", "InvalidSuffixCharacterError", "decode", "fromString", "typeId", "p", "s", "underscoreIndex", "EmptyPrefixError", "PrefixMismatchError", "getSuffix", "typeId", "underscoreIndex", "toUUIDBytes", "decode", "toUUID", "stringify_default", "parseTypeID_default", "props", "typeID", "defaultAction", "typeIdInstance", "fromString", "uuid", "toUUID", "error"]
}
